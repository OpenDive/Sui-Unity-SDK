//
//  SuiPublicKeyBase.cs
//  Sui-Unity-SDK
//
//  Copyright (c) 2024 OpenDive
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

using System;
using System.Linq;
using Chaos.NaCl;
using Org.BouncyCastle.Crypto.Digests;
using Sui.Accounts;
using Sui.Utilities;
using static Sui.Cryptography.SignatureUtils;

namespace Sui.Cryptography
{
    /// <summary>
    /// Implementation of a Sui Public Key value.
    /// </summary>
    public abstract class SuiPublicKeyBase : PublicKeyBase
    {
        /// <summary>
        /// Signature scheme for the public key.
        /// </summary>
        public abstract SignatureScheme SignatureScheme { get; }

        public SuiPublicKeyBase(byte[] public_key) : base(public_key) { }

        public SuiPublicKeyBase(string public_key) : base(public_key) { }

        /// <summary>
        /// Return the Sui representation of the public key encoded in
        /// base-64. A Sui public key is formed by the concatenation
        /// of the scheme flag with the raw bytes of the public key.
        /// </summary>
        /// <returns>The public key as a Sui Address</returns>
        public string ToSuiPublicKey() => CryptoBytes.ToBase64String(this.ToSuiBytes());

        /// <summary>
        /// Creates a PublicKey object from a base-64 or hex
        /// string representation of a Sui-formatted public key.
        /// A Sui public key is formed by the concatenation
        /// of the scheme flag with the raw bytes of the public key.
        /// </summary>
        /// <param name="sui_public_key">The string representation of the Sui Public Key.</param>
        /// <returns>A `SuiPublicKeyBase` conformed Public Key.</returns>
        public SuiPublicKeyBase GetSuiPublicKey(string sui_public_key)
        {
            if (sui_public_key == null)
                return this.SetError<SuiPublicKeyBase, SuiError>(null, "Input public key is null.", sui_public_key);

            byte[] sui_key_value;

            if (Utils.IsValidHexKey(sui_public_key))
                sui_key_value = CryptoBytes.FromHexString(sui_public_key);
            else if (Utils.IsBase64String(sui_public_key))
                sui_key_value = CryptoBytes.FromBase64String(sui_public_key);
            else
                return this.SetError<SuiPublicKeyBase, SuiError>(null, "Invalid key value.", sui_public_key);

            byte[] key_value = new byte[] { };
            byte flag = sui_key_value[0];
            Array.Copy(sui_key_value, 1, key_value, 0, this.KeyLength - 1);

            if (key_value.Length != (this.KeyLength + 1))
                return this.SetError<SuiPublicKeyBase, SuiError>(null, $"Invalid key length: {key_value.Length}", key_value);

            SignatureScheme signature_scheme = SignatureFlagToScheme.GetScheme(flag);

            switch (signature_scheme)
            {
                case SignatureScheme.ED25519:
                    return new Ed25519.PublicKey(key_value);
                default:
                    return this.SetError<SuiPublicKeyBase, SuiError>(null, "Signature scheme is not implemented.", key_value);
            }
        }

        /// <summary>
        /// Signature is committed to the intent message of the transaction data,
        /// as base 64 encoded string.
        /// A serialized signature has the following format:
        /// (`flag || signature || pubkey` bytes, as base-64 encoded string).
        /// </summary>
        /// <param name="message">The message as a byte array.</param>
        /// <param name="serialized_signature">The serialized signature as a base 64 string value.</param>
        /// <returns>A bool value representing whether or not the serialized signature was generated by the public key.</returns>
        public bool Verify(byte[] message, string serialized_signature)
        {
            SuiResult<ParsedSignatureOutput> parsed_signature_result
                = SignatureUtils.ParseSerializedSignature(serialized_signature);

            if (parsed_signature_result.Error != null)
                return this.SetError<bool, SuiError>(false, parsed_signature_result.Error.Message, null);

            ParsedSignatureOutput parsed_signature = parsed_signature_result.Result;

            if (parsed_signature.SignatureScheme != this.SignatureScheme)
                return this.SetError<bool, SuiError>
                (
                    false,
                    $"Signature scheme {parsed_signature.SignatureScheme} does not match {this.SignatureScheme}.",
                    null
                );

            if (this.KeyBytes.SequenceEqual(parsed_signature.PublicKey))
                return this.SetError<bool, SuiError>
                (
                    false,
                    $"Signature public key [{parsed_signature.PublicKey.ToReadableString()}] does not match [{this.KeyBytes.ToReadableString()}].",
                    null
                );

            return this.Verify(message, parsed_signature.Signature);
        }

        /// <summary>
        /// Verifies a Sui Transaction Block with the corresponding Public Key.
        /// </summary>
        /// <param name="transaction_block">The transaction block as a byte array.</param>
        /// <param name="signature">The signature created by the corresponding Public Key.</param>
        /// <returns>A bool representing whether or not the transaction block inputted corresponds to the inputted signature.</returns>
        public bool VerifyTransactionBlock(byte[] transaction_block, SignatureBase signature)
            => this.VerifyWithIntent(transaction_block, signature, IntentScope.TransactionData);

        /// <summary>
        /// Verify the inputted byte array and given intent scope with the given signature.
        /// </summary>
        /// <param name="bytes">The byte array of the intent.</param>
        /// <param name="signature">The signature created by the corresponding Public Key.</param>
        /// <param name="intent">The `IntentScope` value representing the given byte array.</param>
        /// <returns>A bool representing whether or not the byte array and intent scope inputted corresponds to the inputted signature.</returns>
        public bool VerifyWithIntent(byte[] bytes, SignatureBase signature, IntentScope intent)
        {
            byte[] intent_message = CreateMessageWithIntent(intent, bytes);

            // BLAKE2b hash
            byte[] digest = new byte[this.KeyLength];
            Blake2bDigest blake2b = new Blake2bDigest(256);
            blake2b.BlockUpdate(intent_message, 0, intent_message.Length);
            blake2b.DoFinal(digest, 0);

            return this.Verify(digest, signature.SignatureBytes);
        }

        // TODO: Implement VerifyPersonalMessage.
        public bool VerifyPersonalMessage() => throw new NotImplementedException();

        // TODO: Implement Verify with SignatureBase object.
        /// <summary>
        /// Signature is committed to the intent message of the transaction data,
        /// as a `SignatureBase` object.
        /// A serialized signature has the following format:
        /// (`flag || signature || pubkey` bytes, as base-64 encoded string).
        /// </summary>
        /// <param name="message">The message as a byte array.</param>
        /// <param name="signature">The serialized signature as a `SignatureBase` object.</param>
        /// <returns>A bool value representing whether or not the serialized signature was generated by the public key.</returns>
        public bool Verify(byte[] message, SignatureBase signature)
            => throw new NotImplementedException();

        /// <summary>
        /// Byte representation of the public key
        /// prefixed with the signature scheme flag.
        /// (SIGNATURE_SCHEME_FLAG (byte) | Public Key Bytes)
        /// </summary>
        /// <returns>A byte array of the concat with the Signature Scheme flag and Public Key bytes.</returns>
        public byte[] ToSuiBytes()
        {
            byte[] sui_bytes = new byte[this.KeyLength + 1];
            sui_bytes[0] = this.Flag();
            Array.Copy(this.KeyBytes, 0, sui_bytes, 1, this.KeyBytes.Length);

            return sui_bytes;
        }

        /// <summary>
        /// Convert the Public Key bytes to a valid Sui Address.
        /// (SIGNATURE_SCHEME_FLAG (byte) | Public Key Bytes)
        /// </summary>
        /// <returns>The string value of the Sui Address.</returns>
        public AccountAddress ToSuiAddress()
        {
            // Set up address byte arrays.
            byte[] prehash_address = this.ToSuiBytes();
            byte[] hashed_address = new byte[this.KeyLength];

            // Hash the prehash array.
            Blake2bDigest blake2b = new Blake2bDigest(256);
            blake2b.BlockUpdate(prehash_address, 0, prehash_address.Length);
            blake2b.DoFinal(hashed_address, 0);

            // Convert to hex and normalize address.
            string address_hex = CryptoBytes.ToHexStringLower(hashed_address);
            return AccountAddress.FromHex(address_hex);
        }

        /// <summary>
        /// Serializes the given signature to a string.
        /// </summary>
        /// <param name="signature">The signature to serialize as a `SignatureBase`.</param>
        /// <returns>The `SignatureBase` as a string.</returns>
        public SuiResult<string> ToSerializedSignature(SignatureBase signature)
            => SignatureUtils.ToSerializedSignature
               (
                   new SerializeSignatureInput
                   (
                       this.SignatureScheme,
                       signature.SignatureBytes,
                       this
                   )
               );
    }
}

